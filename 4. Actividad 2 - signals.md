# Actividad 2: Mejorando el Juego con Signals - Angular 20

## Objetivo
Transformar el juego de números básico en una aplicación profesional utilizando **Signals** de Angular 20, mejorando el diseño para crear una experiencia de juego más atractiva y funcional.

## Prerequisitos
- Haber completado la **Actividad 1** (juego básico de números)
- Conocimientos básicos de HTML, CSS y TypeScript
- Aplicación Angular 20 funcionando

## Lo que aprenderás
- ¿Qué son los **Signals** y por qué son importantes?
- Implementar **reactividad moderna** en Angular
- Crear interfaces de usuario **más responsivas** y **profesionales**
- Transformar variables tradicionales en **Signals reactivos**
- Mejorar la **experiencia de usuario** con diseño atractivo

---

## 🎯 ¿Qué son los Signals?

### Definición simple
Los **Signals** son como **cajas inteligentes** que:
- Guardan información (como variables normales)
- **Avisan automáticamente** cuando cambian
- **Actualizan la interfaz** sin código extra

### Analogía del semáforo 🚦
Imagina un semáforo:
- Cuando cambia de rojo a verde → **todos los autos se enteran automáticamente**
- Con Signals: cuando un valor cambia → **toda la interfaz se actualiza sola**

### Comparación práctica

#### ❌ Antes (manera tradicional):
```typescript
export class JuegoViejo {
  numeroActual = 0;
  mensaje = 'Presiona el botón';
  
  generarNumero() {
    this.numeroActual = Math.floor(Math.random() * 10) + 1;
    this.mensaje = 'Número generado!';
    // Muchas veces Angular no detectaba los cambios automáticamente
  }
}
```

#### ✅ Ahora (con Signals):
```typescript
export class JuegoNuevo {
  numeroActual = signal(0);
  mensaje = signal('Presiona el botón');
  
  generarNumero() {
    this.numeroActual.set(Math.floor(Math.random() * 10) + 1);
    this.mensaje.set('Número generado!');
    // ¡La interfaz se actualiza AUTOMÁTICAMENTE! ✨
  }
}
```

---

## 🌟 ¿Por qué son importantes los Signals?

### 1. **Rendimiento mejorado** 🚀
- Solo actualiza lo que realmente cambió
- Apps hasta **30% más rápidas**
- Menos consumo de recursos

### 2. **Código más simple** 📝
- Menos líneas de código
- Más fácil de entender
- Menos errores

### 3. **Reactividad automática** ⚡
- Los cambios se propagan solos
- No hay que preocuparse por detectar cambios manualmente

### 4. **Mejor experiencia de desarrollo** 👨‍💻
- Debugging más claro
- Errores más comprensibles
- Herramientas mejoradas

---

## 🎮 ¿Dónde se utilizan los Signals?

### 1. **Gestión de estado** (lo más común)
```typescript
const puntuacion = signal(0);
const vidas = signal(3);
const nivel = signal(1);
```

### 2. **Datos calculados automáticamente**
```typescript
const puntuacion = signal(100);
const multiplicador = signal(2);
const puntuacionFinal = computed(() => puntuacion() * multiplicador());
// Si puntuacion o multiplicador cambian, puntuacionFinal se actualiza solo!
```

### 3. **Formularios reactivos**
```typescript
const nombre = signal('');
const email = signal('');
const formularioValido = computed(() => 
  nombre().length > 0 && email().includes('@')
);
```

### 4. **Interfaces de usuario dinámicas**
```typescript
const temaOscuro = signal(false);
const colorFondo = computed(() => 
  temaOscuro() ? '#000000' : '#ffffff'
);
```

---

## 📚 Tipos de Signals - Ejemplos prácticos

### 1. **Signal básico** (una caja que puedes cambiar)
```typescript
// Para guardar valores simples
const contador = signal(0);
const nombre = signal('Jugador');
const estaJugando = signal(false);

// Para cambiar valores
contador.set(10);              // Valor exacto
contador.update(n => n + 1);   // Basado en valor anterior
```

### 2. **Computed Signal** (se calcula automáticamente)
```typescript
const puntos = signal(0);
const bonus = signal(50);

// Se actualiza automáticamente cuando puntos o bonus cambian
const puntuacionTotal = computed(() => puntos() + bonus());

puntos.set(100);  // puntuacionTotal ahora es 150 ¡automáticamente!
```

### 3. **Input Signals** (para recibir datos)
```typescript
@Component({
  selector: 'app-jugador',
  template: `<h2>Hola {{nombre()}}</h2>`
})
export class JugadorComponent {
  nombre = input<string>('Invitado'); // Recibe el nombre del componente padre
}
```

### 4. **Effect** (para reaccionar a cambios)
```typescript
const puntuacion = signal(0);

// Se ejecuta cada vez que puntuacion cambia
effect(() => {
  console.log(`Nueva puntuación: ${puntuacion()}`);
  
  // Guardar en localStorage automáticamente
  localStorage.setItem('puntuacion', puntuacion().toString());
});
```

---

## 🎯 Tu Misión: Transformar el juego con Signals

### Paso 1: Analiza tu código actual

Busca estas partes en tu `juego-numeros.ts`:
- Variables normales (ej: `numeroActual`, `mensaje`, `intentos`)
- Métodos que cambian esas variables
- Template que muestra esos valores

### Paso 2: Importar Signals

```typescript
import { Component, signal, computed, effect } from '@angular/core';
import { RouterLink } from '@angular/router';
```

### Paso 3: Convertir variables a Signals

#### ❌ Tu código actual probablemente tiene:
```typescript
export class JuegoNumeros {
  numeroActual = 0;
  mensaje = 'Presiona el botón para empezar';
  intentos = 0;
  haGanado = false;
}
```

#### ✅ Conviértelo a Signals:
```typescript
export class JuegoNumeros {
  numeroActual = signal(0);
  mensaje = signal('🎲 Presiona el botón para empezar');
  intentos = signal(0);
  haGanado = signal(false);
  
  // ¡Nuevo! Signal computado que se actualiza automáticamente
  estadoJuego = computed(() => {
    if (this.haGanado()) return '🎉 ¡GANASTE!';
    if (this.intentos() === 0) return '🎮 ¡Listo para jugar!';
    return `🎯 Intento ${this.intentos()}`;
  });
}
```

### Paso 4: Actualizar métodos

#### ❌ Antes:
```typescript
generarNumero() {
  this.numeroActual = Math.floor(Math.random() * 10) + 1;
  this.intentos++;
  
  if (this.numeroActual === 7) {
    this.mensaje = '¡GANASTE!';
    this.haGanado = true;
  } else {
    this.mensaje = 'Sigue intentando';
  }
}
```

#### ✅ Con Signals:
```typescript
generarNumero() {
  const nuevoNumero = Math.floor(Math.random() * 10) + 1;
  
  this.numeroActual.set(nuevoNumero);
  this.intentos.update(i => i + 1);
  
  if (nuevoNumero === 7) {
    this.mensaje.set('🎉 ¡INCREÍBLE! ¡Obtuviste el 7! 🎉');
    this.haGanado.set(true);
  } else if (nuevoNumero > 7) {
    this.mensaje.set('📈 ¡Muy alto! El 7 es menor');
  } else {
    this.mensaje.set('📉 ¡Muy bajo! El 7 es mayor');
  }
}

reiniciarJuego() {
  this.numeroActual.set(0);
  this.mensaje.set('🎲 Presiona el botón para empezar');
  this.intentos.set(0);
  this.haGanado.set(false);
}
```

### Paso 5: Actualizar template HTML

#### ❌ Antes:
```html
<div class="numero-display">{{ numeroActual }}</div>
<div class="mensaje">{{ mensaje }}</div>
<div class="intentos">Intentos: {{ intentos }}</div>
```

#### ✅ Con Signals (¡nota los paréntesis!):
```html
<div class="numero-display">{{ numeroActual() }}</div>
<div class="mensaje">{{ mensaje() }}</div>
<div class="intentos">{{ estadoJuego() }}</div>
<div class="contador">Intentos: {{ intentos() }}</div>
```

---

## 🎨 Diseño profesional - Tu template completo

Reemplaza todo tu `juego-numeros.html` con esto:

```html
<div class="game-container">
  <!-- Header del juego -->
  <header class="game-header">
    <h1 class="game-title">🎲 Juego del Número Mágico</h1>
    <p class="game-subtitle">¿Podrás obtener el número 7?</p>
  </header>

  <!-- Área principal del juego -->
  <main class="game-board">
    <!-- Estado del juego -->
    <div class="status-panel">
      <div class="status-item">
        <span class="status-label">Estado:</span>
        <span class="status-value">{{ estadoJuego() }}</span>
      </div>
      <div class="status-item">
        <span class="status-label">Intentos:</span>
        <span class="status-value">{{ intentos() }}</span>
      </div>
    </div>

    <!-- Display del número -->
    <div class="number-display" [class.winner]="haGanado()">
      <div class="number-label">Tu número es:</div>
      <div class="number-value">
        {{ numeroActual() === 0 ? '?' : numeroActual() }}
      </div>
    </div>

    <!-- Mensaje de feedback -->
    <div class="message-panel" [class.success]="haGanado()">
      {{ mensaje() }}
    </div>

    <!-- Controles del juego -->
    <div class="game-controls">
      <button 
        class="btn btn-primary" 
        (click)="generarNumero()" 
        [disabled]="haGanado()">
        {{ haGanado() ? '🎉 ¡Ganaste!' : '🎲 Lanzar Dado' }}
      </button>
      
      <button 
        class="btn btn-secondary" 
        (click)="reiniciarJuego()"
        *ngIf="intentos() > 0">
        🔄 Nuevo Juego
      </button>
    </div>

    <!-- Estadísticas -->
    <div class="stats-panel" *ngIf="intentos() > 0">
      <h3>📊 Estadísticas</h3>
      <div class="stat-item">
        <span>Probabilidad de ganar:</span>
        <span>10% (1 de 10)</span>
      </div>
      <div class="stat-item">
        <span>Tu efectividad:</span>
        <span>{{ haGanado() ? (100 / intentos()).toFixed(1) : '0' }}%</span>
      </div>
    </div>
  </main>

  <!-- Footer -->
  <footer class="game-footer">
    <a routerLink="/home" class="btn btn-outline">← Volver al Inicio</a>
  </footer>
</div>
```

---

## 🚀 Funcionalidades extra con Signals

### 1. **Agregar historial de números** (Opcional)
```typescript
export class JuegoNumeros {
  // ... tus signals anteriores
  historial = signal<number[]>([]);
  
  generarNumero() {
    const nuevoNumero = Math.floor(Math.random() * 10) + 1;
    
    // Agregar al historial
    this.historial.update(hist => [...hist, nuevoNumero]);
    
    this.numeroActual.set(nuevoNumero);
    // ... resto de tu lógica
  }
  
  reiniciarJuego() {
    this.historial.set([]);
    // ... resto de tu lógica
  }
}
```

### 2. **Sistema de puntuación** (Opcional)
```typescript
export class JuegoNumeros {
  // ... tus signals anteriores
  puntuacion = signal(0);
  
  // Signal computado para nivel de dificultad
  nivelDificultad = computed(() => {
    const intentos = this.intentos();
    if (intentos < 3) return '🟢 Fácil';
    if (intentos < 6) return '🟡 Medio';
    return '🔴 Difícil';
  });
  
  generarNumero() {
    // ... tu lógica actual
    
    if (nuevoNumero === 7) {
      // Calcular puntos basado en intentos
      const puntos = Math.max(100 - (this.intentos() * 10), 10);
      this.puntuacion.update(p => p + puntos);
    }
  }
}
```

### 3. **Effect para guardar progreso** (Opcional)
```typescript
export class JuegoNumeros {
  // ... tus signals anteriores
  
  constructor() {
    // Cargar datos guardados
    const datosGuardados = localStorage.getItem('juegoNumeros');
    if (datosGuardados) {
      const datos = JSON.parse(datosGuardados);
      this.puntuacion.set(datos.puntuacion || 0);
    }
    
    // Effect para guardar automáticamente
    effect(() => {
      const datos = {
        puntuacion: this.puntuacion(),
        ultimaPartida: new Date().toISOString()
      };
      localStorage.setItem('juegoNumeros', JSON.stringify(datos));
    });
  }
}
```

---

## ✅ Lista de verificación

Marca cuando hayas completado cada parte:

### Implementación de Signals:
- [ ] Importaste `signal`, `computed`, `effect`
- [ ] Convertiste todas las variables a signals
- [ ] Actualizaste todos los métodos para usar `.set()` y `.update()`
- [ ] Agregaste paréntesis `()` en el template
- [ ] Creaste al menos un signal computado

### Diseño profesional:
- [ ] Implementaste el nuevo template HTML
- [ ] Aplicaste los estilos CSS profesionales
- [ ] La interfaz es responsive (se ve bien en móvil)
- [ ] Agregaste animaciones y transiciones

### Funcionalidad mejorada:
- [ ] El juego se reinicia correctamente
- [ ] Los mensajes son descriptivos y divertidos
- [ ] Se muestran estadísticas básicas
- [ ] La navegación funciona correctamente

### Funcionalidades extras (opcional):
- [ ] Historial de números
- [ ] Sistema de puntuación
- [ ] Persistencia de datos
- [ ] Niveles de dificultad

---

## 🎯 Resultado esperado

Al completar esta actividad deberías tener:

1. **Una aplicación totalmente reactiva** usando Signals
2. **Interfaz profesional** y atractiva
3. **Mejor rendimiento** y respuesta
4. **Código más limpio** y mantenible
5. **Experiencia de usuario mejorada**

---

## 🔍 Cómo probar que funciona

1. **Abre tu aplicación**: `ng serve`
2. **Ve al juego**: `http://localhost:4200/juego-numeros`
3. **Verifica que:**
   - Los números se actualizan instantáneamente
   - Los mensajes cambian automáticamente
   - Las estadísticas se calculan solas
   - El diseño se ve profesional
   - Funciona bien en móvil

---

## 🎉 ¡Felicidades!

Has completado tu primera aplicación con **Signals de Angular 20**. Ahora entiendes:

- ✅ Qué son los Signals y por qué son útiles
- ✅ Cómo implementar reactividad moderna
- ✅ Crear interfaces profesionales y atractivas
- ✅ Usar TypeScript, HTML y CSS efectivamente
- ✅ Estructurar aplicaciones Angular modernas

**¡Estás listo para crear aplicaciones Angular más avanzadas!** 🚀

---

## 📚 Recursos para seguir aprendiendo

- [Documentación oficial de Angular Signals](https://angular.dev/guide/signals)
- [Angular 20 - Nuevas características](https://angular.dev/roadmap)
- [Guía de CSS Grid y Flexbox](https://css-tricks.com/snippets/css/complete-guide-grid/)
- [TypeScript para principiantes](https://www.typescriptlang.org/docs/)
- ng build --configuration production --base-href "./"
